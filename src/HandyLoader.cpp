
/// ========================================================================
/// libloading (https://github.com/mrpi/libloading)
///
/// License: Boost Software License - Version 1.0, 
///
/// Copyright Ludger Sprenker 2004 - 2006.
///
/// Boost Software License - Version 1.0 - August 17th, 2003
/// Permission is hereby granted, free of charge, to any person or organization
/// obtaining a copy of the software and accompanying documentation covered by
/// this license (the "Software") to use, reproduce, display, distribute,
/// execute, and transmit the Software, and to prepare derivative works of the
/// Software, and to permit third-parties to whom the Software is furnished to
/// do so, all subject to the following:
/// The copyright notices in the Software and this entire statement, including
/// the above license grant, this restriction and the following disclaimer,
/// must be included in all copies of the Software, in whole or in part, and
/// all derivative works of the Software, unless such copies or derivative
/// works are solely in the form of machine-executable object code generated by
/// a source language processor.
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
/// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
/// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
/// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// ========================================================================

/// ========================================================================
/// UNLICENSE
/// 
/// This is free and unencumbered software released into the public domain.
/// Anyone is free to copy, modify, publish, use, compile, sell, or
/// distribute this software, either in source code form or as a compiled
/// binary, for any purpose, commercial or non-commercial, and by any
/// means.
///
/// In jurisdictions that recognize copyright laws, the author or authors
/// of this software dedicate any and all copyright interest in the
/// software to the public domain. We make this dedication for the benefit
/// of the public at large and to the detriment of our heirs and
/// successors. We intend this dedication to be an overt act of
/// relinquishment in perpetuity of all present and future rights to this
/// software under copyright law.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
/// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
/// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
/// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
/// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
/// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
/// OTHER DEALINGS IN THE SOFTWARE.
///
/// For more information, please refer to <http://unlicense.org/>
/// ========================================================================

#include "Common.hpp"

#include <HandyPIMPL.hpp>
#include <HandyLoader.hpp>

#if (defined(_WIN32) || defined(__WIN32__))
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN
#endif

#include <windows.h>
#else
#include <dlfcn.h>
#define HMODULE void*
#endif


namespace HANDY_NS {

	namespace Loader 
	{
		class Exception : public std::exception
		{
			std::string const m_msg;
		public:
			Exception(std::string msg)
				: m_msg(msg) 
			{ }

			virtual ~Exception() throw()
			{ }

			char const * what() const throw() override 
			{ 
				return this->m_msg.c_str(); 
			}

			std::string whatString() const throw() 
			{ 
				return this->m_msg; 
			}
		};

		class Library
		{
			HMODULE     m_lib;
			std::string m_name;

		public:
			Library(std::string name);
			~Library();

			bool        isLoaded() const;

			std::string name()     const { return m_name; }

			HMODULE const & p_library() const;
		};

		Library::Library(std::string name)
			: m_name(name)
		{
			#if (defined(_WIN32) || defined(__WIN32__))
			#ifdef UNICODE
			int len = MultiByteToWideChar(CP_UTF8, 0, name.c_str(), -1, NULL, 0);
			if (len)
			{
				wchar_t * n = new wchar_t[len];
				MultiByteToWideChar(CP_UTF8, 0, name.c_str(), -1, n, len);

				m_lib = LoadLibrary(n);

				delete[] n;
			} 
			else
			{
				m_lib = nullptr;
			}
			#else
			m_lib = LoadLibrary(name.c_str());
			#endif // UNICODE

			if (!m_lib)
			{
				DWORD error = GetLastError();

				std::stringstream err;
				err << "Failed to open library: '" << name << "' with error code: #" << error;

				throw Exception(err.str());
			}
			#else
			m_lib = dlopen(name.c_str(), RTLD_NOW);

			if (!m_lib)
			{
				std::stringstream err;
				err << "Failed to open library '" << name << "': " << dlerror();

				throw Exception(err.str());
			}
			#endif
		}

		Library::~Library()
		{
			if (this->isLoaded())
			{
				#if (defined(_WIN32) || defined(__WIN32__))
				FreeLibrary(m_lib);
				#else
				dlclose(m_lib);
				#endif
			}
		}

		bool Library::isLoaded() const
		{
			return m_lib ? true : false;
		}

		HMODULE const & Library::p_library() const
		{
			return m_lib;
		}

		template <class Signature>
		class Function
		{
			Loader::Library * m_lib;

		public:
			Function(Loader::Library * library, std::string name)
				: m_name(name)
			{
				m_lib = library;

				if (library == nullptr)
				{
					std::stringstream ss;
					ss << "Library is NULL, can't call function: '" << name << "'";

					throw Loader::Exception(ss.str());
				}

				#if (defined(_WIN32) || defined(__WIN32__))

				m_func = reinterpret_cast<Signature*>(GetProcAddress(library->p_library(), name.c_str()));

				if (!m_func)
				{
					std::stringstream err;
					err << "Failed to Retrieve address of function '" << name << "': Windows Error #"
						<< GetLastError() << " for library '" << library->name() << "'";

					throw Loader::Exception(err.str());
				}
				#else

				m_func = reinterpret_cast<Signature *>(dlsym(library->p_library(), name.c_str()));

				if (!m_func)
				{
					std::stringstream err;
					err << "Failed to Retrieve address of function '" << name << "': " << dlerror() << " for library '" << library->name() << "'";

					throw Loader::Exception(err.str());
				}
				#endif
			}

			operator Signature *() const
			{
				if (!m_func)
				{
					std::stringstream ss;
					ss << "Function address '" << m_name + "' isn't resolved for library: '" << m_lib->name() << "'";

					throw Loader::Exception(ss.str());
				}

				return m_func;
			}

			bool        isValid() const { return (bool)m_func; }
			std::string name()    const { return m_name; }

		protected:
			Signature *       m_func;
			std::string const m_name;
		};



	} // Loader

} // HANDY_NS


#if !defined IS_ANDROID && !defined IS_EMSCRIPTEN

	namespace HANDY_NS {

		struct Library::Private
		{
			using ModuleType =
			#ifdef _WIN32
				HMODULE;
			#else
				void*;
			#endif

			ModuleType mHandle;

			ModuleType moduleByPath(std::filesystem::path libFile)
			{
				#ifdef _WIN32
					#ifdef UNICODE
						return ::LoadLibrary(libFile.wstring().c_str());
					#else
						return ::LoadLibrary(libFile.string().c_str());
					#endif
				#else
					return ::dlopen(libFile.u8string().c_str(), RTLD_LAZY);
				#endif
			}

			Private(std::filesystem::path libFile) : mHandle(moduleByPath(libFile)) { }

			~Private()
			{
				if (mHandle != nullptr)
				{
					#ifdef _WIN32
					::FreeLibrary(mHandle); 
					#else
					::dlclose(mHandle);
					#endif
					mHandle = nullptr;
				}
			}
		};

		Library::Alias Library::Symbol(std::string const & name)
		{
			Alias res;

			#ifdef _WIN32
				res.var = ::GetProcAddress(impl->mHandle, name.c_str());
			#else
				res.var = ::dlsym(impl->mHandle, name.c_str());
			#endif

			if (res.var == nullptr)
				#ifdef _WIN32
				throw std::runtime_error("Failed to load symbol");
			#else
				throw std::runtime_error(::dlerror());
			#endif

			return res;
		}


		Library::Library(std::filesystem::path libFile) : impl(HANDY_NS::make_unique_impl<Private>(libFile)){ }

		bool Library::IsValid() const { return impl->mHandle != nullptr; }

		void Library::ThrowIfNotValid() const
		{
			if (!IsValid())
				#ifdef _WIN32
				throw std::runtime_error("Failed to load library.");
			#else
				throw std::runtime_error(::dlerror());
			#endif
		}
	}

#endif